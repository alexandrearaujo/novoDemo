package br.com.mv.demo.model;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.ColumnResult;
import javax.persistence.ConstructorResult;
import javax.persistence.Convert;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.MapKey;
import javax.persistence.MapKeyEnumerated;
import javax.persistence.NamedAttributeNode;
import javax.persistence.NamedEntityGraph;
import javax.persistence.NamedNativeQuery;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.SqlResultSetMapping;
import javax.persistence.Table;

import org.hibernate.annotations.ColumnTransformer;
import org.hibernate.annotations.FetchMode;
import org.hibernate.annotations.FetchProfile;
import org.hibernate.annotations.Formula;
import org.hibernate.annotations.Generated;
import org.hibernate.annotations.GenerationTime;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.LazyGroup;
import org.hibernate.annotations.NaturalId;
import org.hibernate.annotations.Parameter;
import org.hibernate.annotations.Polymorphism;
import org.hibernate.annotations.PolymorphismType;
import org.hibernate.annotations.SortNatural;
import org.hibernate.annotations.Type;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;

import br.com.mv.demo.model.converters.EnumTipoTesteConverter;
import br.com.mv.demo.model.type.EnumTipoTeste;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "TESTE")

@Getter @Setter @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode(of = "id")
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = "id")
@NamedEntityGraph(name = "teste.detalhes",
	attributeNodes = {
						@NamedAttributeNode("detalhes"),
//						@NamedAttributeNode("filhos"),
						@NamedAttributeNode("mappedTestes"),
						@NamedAttributeNode("sortedTestes")
					 }
)
@FetchProfile(
	name = "teste.detalhesProfile",
	fetchOverrides = {
		@FetchProfile.FetchOverride(
		    entity = Teste.class,
		    association = "detalhes",
		    mode = FetchMode.JOIN
	    ),
		@FetchProfile.FetchOverride(
			entity = Teste.class,
			association = "mappedTestes",
			mode = FetchMode.JOIN
		),
		@FetchProfile.FetchOverride(
		    entity = Teste.class,
		    association = "sortedTestes",
		    mode = FetchMode.JOIN
	    )
	}
)
@NamedNativeQuery(
    name = "find_teste_dto",
    query =
        "SELECT " +
        "   id, " +
        "   descricao " +
        "FROM teste ",
    resultSetMapping = "id_descricao_dto"
)
@SqlResultSetMapping(
    name = "id_descricao_dto",
    classes = @ConstructorResult(
        targetClass = TesteWrapper.class,
        columns = {
            @ColumnResult(name = "id"),
            @ColumnResult(name = "descricao")
        }
    )
)
@Inheritance(strategy = InheritanceType.JOINED)
@Polymorphism(type = PolymorphismType.EXPLICIT)
public class Teste implements Serializable {

	/**
	 * Generated by IDE
	 */
	private static final long serialVersionUID = 1L;

	@Id
	@Column(name = "ID")
	@GenericGenerator(name="SEQ_TESTE", strategy="enhanced-sequence",
	   parameters={
	         @Parameter(name="sequence_name", value="SEQ_TESTE"),
	         @Parameter(name="initial_value", value="1"),
	         @Parameter(name="increment_size",value="50"),
	         @Parameter(name="optimizer", value="pooled-lo")
	   }
	)
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ_TESTE")
	private Long id;
	
	@Column(name = "DS_CODIGO")
	@ColumnTransformer(read = "TO_NUMBER(DS_CODIGO)", write = "TO_CHAR(?)")
	private Integer codigo;

	@Basic(fetch = FetchType.LAZY)
	@Column(name = "DESCRICAO")
	@LazyGroup("teste")
	private String descricao;
	
	@NaturalId
	@Column(name = "CPF")
	@LazyGroup("teste2")
	private String cpf;
	
	@Column(name = "TP_SITUACAO")
	@Convert(converter = EnumTipoTesteConverter.class)
	private EnumTipoTeste situacaoTeste;

	@Column(name = "DT_CRIACAO", insertable = false)
	@Generated(GenerationTime.INSERT)
	private LocalDate dataCriacao;
	
	@Column(name = "DH_ATUALIZACAO", insertable = false, updatable = false)
	@Generated(GenerationTime.ALWAYS)
	private LocalDateTime dataAtualizacao;
	
	@Formula("VALOR1 + VALOR2")
	private BigDecimal total;
	
	@Embedded
	@Basic(fetch = FetchType.LAZY)
	@LazyGroup("nome")
	private Nome nome = new Nome();
	
	@OneToMany(cascade = CascadeType.ALL, mappedBy = "teste", orphanRemoval = true)
	@OrderBy(value = "descricao")
//	@JsonBackReference(value = "teste-detalhe")
//	@JsonIgnoreProperties({"teste"})
	private List<DetalheTeste> detalhes = new ArrayList<DetalheTeste>();
	
	@OneToMany(cascade = CascadeType.ALL, mappedBy = "teste", orphanRemoval = true)
//	@JsonBackReference(value = "teste-filho")
//	@JsonIgnoreProperties({"teste"})
	private List<TesteFilhoTeste> filhos = new ArrayList<TesteFilhoTeste>();
	
	@OneToMany(mappedBy = "teste", cascade = CascadeType.ALL)
	@SortNatural 
//	@SortComparator(SortedTesteReverseComparator.class)
//	@JsonBackReference(value = "teste-sorted")
//	@JsonIgnoreProperties({"teste"})
	private SortedSet<SortedTeste> sortedTestes = new TreeSet<SortedTeste>();
	
	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinTable(
            name = "TESTE_MAPPED_TESTE",
            joinColumns = @JoinColumn(name = "CD_TESTE"),
            inverseJoinColumns = @JoinColumn(name = "CD_MAPPED_TESTE"))
	@MapKey(name = "situacaoTeste")
    @MapKeyEnumerated
    private Map<EnumTipoTeste, MappedTeste> mappedTestes = new HashMap<EnumTipoTeste, MappedTeste>();
	
	@Type(type = "comma_delimited_strings")
	@Column(name = "FONES")
    private List<String> phones = new ArrayList<String>();
	
	
	public void addDetalhe(DetalheTeste detalhe) {
		detalhes.add(detalhe);
		detalhe.setTeste(this);
	}
	
	public void removeDetalhe(DetalheTeste detalhe) {
		detalhes.remove(detalhe);
		detalhe.setTeste(null);
	}
	
	public void addFilho(FilhoTeste filhoTeste) {
		TesteFilhoTeste filho = new TesteFilhoTeste(this, filhoTeste);
		filhos.add(filho);
		filhoTeste.getPais().add(filho);
	}
	
	public void removeFilho(FilhoTeste filhoTeste) {
		TesteFilhoTeste filho = new TesteFilhoTeste(this, filhoTeste);
		filhoTeste.getPais().remove(filho);
		filhos.remove(filhoTeste);
		filho.setFilhoTeste(null);
		filho.setTeste(null);
	}
	
	public void addSortedTeste(SortedTeste sortedTeste) {
		sortedTestes.add(sortedTeste);
		sortedTeste.setTeste(this);
	}
	
	public void removeSortedTeste(SortedTeste sortedTeste) {
		sortedTestes.remove(sortedTeste);
		sortedTeste.setTeste(null);
	}
	
	public void addMappedTeste(MappedTeste mappedTeste) {
		mappedTestes.put(mappedTeste.getSituacaoTeste(), mappedTeste);
	}
	
//	@ElementCollection
//    @CollectionTable(
//        name="teste_nome",
//        joinColumns=@JoinColumn(name="teste_id")
//    )
//    @OrderColumn(name = "index_id")
//    private List<Nome> nomes = new ArrayList<>();

}
